## 拷贝构造函数
> 如果一个构造函数的第一个参数是自身类类型的引用，如果有额外参数且任何额外的参数都有默认值(只能在声明的时候给出)，则此构造函数是拷贝构造函数.
```` cpp

class Complex
{
public:
    //拷贝构造函数1
    Complex(const Complex &c);
    //拷贝构造函数2
    Complex(Complex &c);
    
private:
    CTest* pointer;
    
}

/*
例子中拷贝构造函数1才是系统默认的拷贝构造函数，在自己写的代码中这两个拷贝构造函数都没有什么问题，但是如果用于stl模板参数时，第二个拷贝构造函数往往会出现一些莫名其妙的错误，为了谨慎起见，以后拷贝构造函数的参数都用const修饰
*/
````


**拷贝构造函数应用的场景：**

    - 用一个对象初始化另外一个对象(不是实例化后赋值, 那会调用重载的赋值函数`=`):
    
```` cpp
//因为是初始化, 拷贝构造函数
CTest test1;
CTest test2 = test1;
CTest test2  (test1); 

//对象是已经存在的, 调用的是重载的赋值运算符
CTest test1，test2;
test2 = test1;
````

    - 函数的`参数`是一个对象,并且是值传递方式
    - 函数的返回值是一个对象,并且是值传递方式
    
----
### 自定义拷贝构造函数

**特别注意的是定义一个类时，编译器会给我们定义一个默认拷贝构造函数, 对于类中普通的成员变量，如int, double, char等，c++提供默认的拷贝构造函数，我们可以不用写拷贝构造函数。如果类中成员有*指针（深拷贝，浅拷贝问题），那么我们就需要写自己的拷贝构造函数和重载的赋值函数**

**防止默认拷贝发生**
    通过对对象复制的分析，我们发现对象的复制大多在进行“值传递”时发生，这里有一个小技巧可以防止按值传递——声明一个私有拷贝构造函数。甚至不必去定义这个拷贝构造函数，这样因为拷贝构造函数是私有的，如果用户试图按值传递或函数返回该类对象，将得到一个编译错误，从而可以避免按值传递或返回对象。

### 何时提供缺省构造函数和缺省复制构造函数
``` cpp
|用户是否定义构造函数|用户是否定义复制构造函数函数|编译器是否提供缺省构造函数|编译器是否提供缺省复制构造函数|
|        N        |            N          |            Y         |            Y            |
|        N        |            Y          |            N         |            N            |<--just this is special.
|        Y        |            N          |            N         |            Y            |
|        Y        |            Y          |            N         |            N            |


### 提示: 何时调用不同的构造函数

> 一句话记住三者：

- 对象不存在，且没用别的对象来初始化，就是调用了构造函数；

- 对象不存在，且用别的对象来初始化，就是拷贝构造函数（上面说了三种用它的情况！）

- 对象存在，用别的对象来给它赋值，就是赋值函数。


