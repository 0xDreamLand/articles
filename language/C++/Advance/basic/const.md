## 1. `const` 限定符概述
const 限定其后紧接着的一个程序字段为 `不可变`, 例如 const int *p:限定int不可变，即p指向的int型数， 而int * const p:限定指针p本身不可变，由于不可变,const对象声明时一定要初始化.

## 2. const 与 #define 及其编译器相关

- 在`const TYPE a;`中a是一个不可变的 `变量` ，const只是一个限定符，a本质上是变量，其不可变属性只有当要修改a时才体现出来. const 定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。其他情况下(const class A...)它只是一个 const 限定的变量，不要将与常量混淆。 若用 const 定义常量（类型为整数或枚举，必须以常量表达式初始化），则这种常量在非 odr 式使用（粗略来说是只使用其值）时不需要依赖其身为变量的身份，一定场合下甚至可以不需要定义（譬如作为类的 static 成员对象）。

- #define 除其专有用途外, 当定义常量时, 其仅仅在编译的预处理阶段展开替换.  

- 编译器在作为常量处理它时，不会依赖“一份定义”，而是像是立即数一样使用它，它本身可能在机器码中被“拷贝”到多个地方，和 #define 定义的宏常量的结果相同。另一方面， const 定义的常量由于是整数或枚举，所以直接变成机器码上的立即数往往性能更好。

- ### 小结: 下面这段代码揭示了所有的秘密:[ 编译器在编译的语法层面阻止你改变const int对象，但会像正常变量一样为他开辟内存，但又对直接使用常量的地方进行直接替换]
``` cpp
#include <iostream>

int main() {

    const int i = 7;
    int &i_ = (int &) i;
    i_ = 18;

    std::cout << i << " " << *(&i) << std::endl;
    
    return 0;
}

cout : 7 18 
```

## 3. const 的默认作用范围 : 文件

如上所述， `const int bufsize = 512;` 是以常量表达式初始化的且const限定的int型变量，编译器将其看成常量表达式, 也就是说编译器会找到代码中所有用到bufsize的地方，然后用512将其替换. 为了执行替换编译器必须知道变量的初始值, 问题在于，如果程序的多个文件用了这个const对象，就必须在每个用到该变量的文件中对他定义，为了支持这一做法同时避免重复定义， 默认情况下const对象被设定为仅在文件内有效, 所以多个文件中的同名const对象是分别定义的独立对象.

某些时候有这样一种const变量, 它的初始值不是常量表达式,但确实有必要在文件中共享. 即我们很难或不希望在多个文件中同时定义多个独立变量, 也就是说我们希望在一个文件中定义它，在其他多个文件中声明并使用它，解决办法就是无论声明还是定义，都在之前添加extern关键字，例如：
``` cpp
file_1.cc
extern const int bufsize = func();

file_2.cc
extern const int bufsize; // 与file_1.cc 中的是同一个
```
> 对于未被const修饰的变量在不同文件的访问, 只需要在使用方的多个文件中，使用extern修饰声明即可.

## 4. const 与 引用
> 引用的类型必须与其引用对象的类型相同, 有两个例外, 一是对象的类型含有一个可接受的const类型转换规则, 二是我们可以将基类的指针或引用绑定到派生类对象上。

- 对常量的引用如下, 没什么问题，满足左右类型相同，同时对常量的引用本来就要求常量不可变(因为他本来就不可变)
``` cpp
const int test = 1024;
const int &tst = test;
/*
需要指出的是一些程序员将对常量的引用简称为常量引用，你最好时刻记得这是简称，因为并不存在什么常量引用(不存在: int& const p)，引用并不是一个对象，我们没法让他恒定不变，同时由于C++并不允许随意改变引用所绑定的对象，从某种意义上讲，所有的引用又都算常量。
*/

```

- 上面标题中说的第一个例外是指：允许常量引用绑定到一个非常量的对象，字面值，甚至是一个表达式, 当然还有类型不同的const。
``` cpp
int i = 42;
const int &r1 = i;      //不用中间临时变量转换
const int &r2 = 4;      //实际绑定到中间临时变量
const int &r3 = r1 * 2; //实际绑定到中间临时变量

double m = 23.33f;
const int &r5 = m;      //实际绑定到中间临时变量

const double t = 34.34;
const int &r6 = t;      //实际绑定到中间临时变量
```
说明一下： 上面的例子对非常量和字面值的绑定分为两种情况:<br/>
一.{当绑定的是字面值或不同类型时，即[可接受的const类型转换规则]}， 会生成一个中间临时变量， 实际是对临时变量的绑定， 这也是为什么不允许引用不同的类型如(double a; int &i = a;), 因为没有人想修改一个中间临时变量。

二.{当绑定的是同类型的非const对象时}，表示不允许由当前这个绑定来修改对象, 我只需要在这个地方用一下，你在其他地方改不改我不管。



## 5. const 与 指针

``` cpp

const int *p;                                                                     
int const *p;           //const后为int 或 * 都表示修饰的是指向的内容不可变        
int *const p = initial; //指针本身不可变, 所以必须初始化. 
```

## 6. const 与 函数

> const限定返回值或者函数参数没什么特别的.

## 7. const 与 类

- const成员变量可以通过类的初始化列表或声明时直接初始化, 且必须初始化.
- 任何成员函数都能访问const成员变量，切都不能更改, 这理所当然, 但const函数任何东西都不能修改.
- const函数不能调用非const函数.
- 不能将静态方法限定为const,这是多余的, 因为静态方法没有类的实例，因此不能改变内部的值.
- 有时候"逻辑上"为const的成员函数, 不得不改变一个值, 你可以将这个变量用mutable修饰.

    ### 1> 类内 static const 变量的初始化
    首先静态变量只能外部初始化, 因为他和类的内存分配是相对独立的, 构造时彼此又有一定的依赖关系,所以要分开定义，才有先后顺序，同理也不能使用初始化列表，因为初始化列表正是在构造类时用到的. 同时我们知道const成员变量能在声明时或者初始化列表定义. 那到底是根据谁来定义变量呢, 答案是根据static, 在外部定义, 但是这里有一个问题, `如果你在头文件内声明const static成员变量，而在具体源cpp文件内实现其初始化, 因为这样编译器需要根据具体的实现文件来确定该成员变量的初始值，若实际应用中没有相应的实现文件(源cpp文件)来对这个成员变量实现初始化，则编译器无法明确意图，从而无法完成编译, 但是没有遗漏的话就可以这么做` C++11为了更加合理，可以在类内声明时就初始化.
    
> static 只用于声明的时候, 而对于const方法, const关键字是函数原型的一部分, 定义时也必须有.
    


## 8. constexpr
> 必须在编译时就能确定其值.

