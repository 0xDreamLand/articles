
## 1. inline 通用属性
### inline 概述
- 内联函数是C++为了提高程序运行速度而作出的一种改进。在函数定义前加上inline关键字，就可以使用内联函数的特性。强调一下，必须是函数定义的地方，原因后面解释。普通函数和内联函数的主要区别是函数与程序的组合形式的不同。
- 首先，inline关键字在函数编译阶段生效，其作用是在函数的调用点直接展开函数的代码，若本文件没有调用内联函数的地方，编译器将不对其函数生成符号，此时内联函数只是对本文件可见.
- 内联函数的本质是以代码膨胀为代价，典型的以空间换时间。因此在使用inline关键字时需要对根据实际情况而定，下面给出inline关键字的使用建议：
    
    > 当函数的执行开销<函数开栈清栈的开销时，说明函数代码体较小，建议使用inline关键字
    > 当函数的执行开销>函数开栈清栈的开销时，说明函数代码体较大，不建议使用inline关键字

### inline 函数的定义 : 

#### inline 是一种“用于实现的关键字”
    关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。因此，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。
一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：

    声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。


#### 建inline函数的定义放在头文件中
> 高级编译器不要求将内联方法定义到头文件中， 请保证你了解这款编译器

- 因为内联函数要在调用点展开，所以编译器必须随处可见内联函数的定义，要不然就成了非内联函数的调用了。这要求：<br/>
`每个调用了内联函数的文件都出现了该内联函数的定义` 因此，将内联函数的定义放在头文件里实现是合适的，省却为每个文件实现一次的麻烦。

- 声明跟定义要一致：<br/>
如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的，否则，将会引起未定义的行为。如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。


### inline 与宏对比
> 内敛函数的功能和宏定义（#define ）差不多，即在编译阶段进行替换，减少运行时间，提高运行效率。区别是宏定义没有语法检查，内敛函数有语法检查，更不会出错！而宏展开只是简单的文本替换，用表达式换表达式，用参数换参数，
``` cpp

#define fun(x) ((x > 5) && (x < 10)) ? x : 0 
int c = 7; 
int d = Fun(++c); 
/*
这里应该换为( (++c>5)&&(++c<10)? ++c:0 ) 
执行结果应该是10，10
但注意，如果改为内敛函数，这里结果应该是8，8. 因为函数是单向值传递！而宏替换是简单的文本替换！
*/
```

### inline 注意事项
- 内联函数只是给编译器的一个建议，具体情况根据编译器的规则决定
- 内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果；但是，如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大
- 很多编译器不允许inline递归
- 一些高级编译器支持inline调试, 假装跳到函数

## 2. inline 与 类

### 隐式内联
[`定义`]在类中的成员函数缺省都是内联的

    如果在类定义时就在类内给出函数定义，那当然最好。
    如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的。
    
``` cpp
class A
{
    public:void Foo(int x, int y) {  } // 自动地成为内联函数
}
```

将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：
``` cpp

class A
{
    public:
    void Foo(int x, int y);
}
inline void A::Foo(int x, int y){} 
```
> 需要注意的是, 可以放在类的外部定义，但是大多数编译器还是要在同一个.h中，否则inline不会生效
> 再一次的, 了解你的编译器, 否则就用保守的方法.


### 虚函数内联

- 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
- 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
- inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。
    
``` cpp
#include <iostream>  
using namespace std;
class Base
{
public:
    inline virtual void who()
    {
        cout << "I am Base\n";
    }
    virtual ~Base() {}
};
class Derived : public Base
{
public:
    inline void who()  // 不写inline时隐式内联
    {
        cout << "I am Derived\n";
    }
};

int main()
{
    // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
    Base b;
    b.who();

    // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
    Base *ptr = new Derived();
    ptr->who();

    // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
    delete ptr;
    ptr = nullptr;

    return 0;
} 
```
